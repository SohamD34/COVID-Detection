# -*- coding: utf-8 -*-
"""PRML - Major Project - COVID Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DAhjdFkPb2Npgb1KIT5lCeQ6kRGm1Qb3

# LIBRARIES
"""

''' IMPORTING LIBRARIES THAT WILL BE USEFUL DURING THE IMPLEMENTATION '''

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
import sklearn
import seaborn as sb
import scipy as sp
import PIL
from PIL import Image
import requests
from IPython.display import display
import torch
import os
import cv2
import torchvision
import torchvision.transforms as transforms
from sklearn.decomposition import PCA
from sklearn.decomposition import FastICA
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import classification_report
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.cluster import KMeans
from sklearn.metrics import accuracy_score, f1_score, precision_score, roc_auc_score, silhouette_score
from sklearn.tree import DecisionTreeClassifier as DTC
from sklearn.ensemble import RandomForestClassifier as RFC
from sklearn.inspection import DecisionBoundaryDisplay
from xgboost.sklearn import XGBClassifier 
from sklearn.neighbors import KNeighborsClassifier


from google.colab import drive
drive.mount('/content/drive')

"""# DATASET"""

combined_dataset = []
Y_values = []

"""## Pneumonia chest scans"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/COVID-19_Radiography_Dataset/COVID-19_Radiography_Dataset/Viral Pneumonia/images

''' STORING THE IMAGES OF CHEST SCANS FOR PNEUMONIA  '''

files = os.listdir('.')
image_files = []

for file in files:
    if file.endswith(('jpg', 'jpeg', 'png', 'bmp')):
        image_files.append(file)

image_list = []
for image_file in image_files:
    img = Image.open(image_file).convert('L')
    resized_img = img.resize((250, 250))
    img_array = np.array(resized_img)
    image_list.append(img_array)
    img = None
    img_array = None

pneumonia_imgs = image_list
combined_dataset.extend(pneumonia_imgs)

for i in range(len(pneumonia_imgs)):
    Y_values.append(0)
pneumonia_imgs = None
image_list = None

# Commented out IPython magic to ensure Python compatibility.
# %rm -rf /content/drive/MyDrive/COVID-19_Radiography_Dataset/COVID-19_Radiography_Dataset/Viral Pneumonia

"""## COVID datasets"""

df = pd.read_excel('/content/drive/MyDrive/COVID-19_Radiography_Dataset/COVID-19_Radiography_Dataset/COVID.metadata.xlsx')
urls = list(df['URL'])
uniq_urls = list(set(urls))

!git clone https://github.com/ieee8023/covid-chestxray-dataset.git

!git force clone https://github.com/armiro/COVID-CXNet

!wget https://sirm.org/category/senza-categoria/covid-19/

!wget https://eurorad.org/

"""## Checking and combining all the dataset sources"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/COVID-CXNet/chest_xray_images/covid19

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/covid-chestxray-dataset/images

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/COVID-19_Radiography_Dataset/COVID-19_Radiography_Dataset/COVID-19 Dataset/X-ray/COVID

files = os.listdir('.')
image_files = [file for file in files if file.endswith(('jpg', 'jpeg', 'png', 'bmp'))]

image_list = []
for image_file in image_files:
    if len(image_list)<1000:
        img = Image.open(image_file).convert('L')
        resized_img = img.resize((250, 250))
        img_array = np.array(resized_img)
        image_list.append(img_array)
        img = None
        resized_img = None
        img_array = None
    else:
        break

radiology_array = image_list
combined_dataset.extend(radiology_array)
for i in range(len(radiology_array)):
    Y_values.append(1)
image_list = None

# Commented out IPython magic to ensure Python compatibility.
# %rm -rf /content/drive/MyDrive/COVID-19_Radiography_Dataset/COVID-19_Radiography_Dataset/COVID-19 Dataset/X-ray/COVID

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/SIRM Xrays

files = os.listdir('.')
image_files = [file for file in files if file.endswith(('jpg', 'jpeg', 'png', 'bmp'))]

image_list = []
for image_file in image_files:
    if len(image_list)<1000:
        img = Image.open(image_file).convert('L')
        resized_img = img.resize((250, 250))
        img_array = np.array(resized_img)
        image_list.append(img_array)
        img = None
        resized_img = None
        img_array = None
    else:
        break

sirm_array = image_list
combined_dataset.extend(sirm_array)
for i in range(len(sirm_array)):
    Y_values.append(1)
image_list = None

# Commented out IPython magic to ensure Python compatibility.
# %rm -rf /content/drive/MyDrive/SIRM Xrays

"""# DATA PREPROCESSING

## Converting to DataFrame
"""

dset = np.array(combined_dataset)
dset = dset.reshape((2412,62500))

df = pd.DataFrame(dset)
df['COVID-Class'] = Y_values
df = df.sample(frac=1)
df

df1 = df.copy()

# FEATURE DATA

X = df.iloc[:,:-1]
X

"""## PCA reduction"""

X = df.iloc[:,:-1]
Y = df.iloc[:,-1]

pca = PCA(n_components=20)
pca_X = pca.fit_transform(X)
pca_X = pd.DataFrame(pca_X)
pca_X

pca_X_train,pca_X_test,pca_Y_train,pca_Y_test = train_test_split(pca_X,Y, train_size = 0.7)

"""## ICA reduction"""

ica = FastICA(n_components=2)
ica_X = ica.fit_transform(X)
ica_X = pd.DataFrame(ica_X)
ica_X

ica_X_train,ica_X_test,ica_Y_train,ica_Y_test = train_test_split(ica_X,Y, train_size = 0.7)

"""# DATA VISUALISATION

## Data Distribution
"""

L = list(df['COVID-Class'])
c0 = L.count(0)
c1 = L.count(1)
explode = [0,0.2]
plt.pie([c0,c1],labels = ["COVID","Non-COVID"],explode = explode,shadow=True,autopct='%1.1f%%')
plt.title("Data distribution")
plt.show()

# AFTER PCA 

fi,ax=plt.subplots(figsize=(18,18))
sb.heatmap(pca_X.corr(),annot=True, linewidths=.5, fmt='.1f',ax=ax)

# AFTER ICA

fi,ax=plt.subplots(figsize=(8,8))
sb.heatmap(ica_X.corr(),annot=True, linewidths=.5, fmt='.1f',ax=ax)

"""## COVID Data Images"""

cov_data = df[df["COVID-Class"]==1]
fig,axs = plt.subplots(2,5, figsize=(15,15))

x = 0
y = 0

for i in range(10):
    a = np.random.randint(0,len(cov_data))
    img_data = np.array(cov_data.iloc[a,:-1])
    img = img_data.reshape(250,250)
    axs[x,y].imshow(img, cmap='gray')

    if (x==0 and y<4):
        y+=1
    elif (x==1 and y<4):
        y+=1
    else:
        x+=1
        y=0

plt.show()

"""## Non-COVID Data Images"""

non_cov_data = df[df["COVID-Class"]==0]
fig,axs = plt.subplots(2,5, figsize=(15,15))

x = 0
y = 0

for i in range(10):
    a = np.random.randint(0,len(non_cov_data))
    img_data = np.array(non_cov_data.iloc[a,:-1])
    img = img_data.reshape(250,250)
    axs[x,y].imshow(img, cmap='gray')

    if (x==0 and y<4):
        y+=1
    elif (x==1 and y<4):
        y+=1
    else:
        x+=1
        y=0

plt.show()

"""# UNSUPERVISED LEARNING"""

learning_models = []
pca_accuracies = []
ica_accuracies = []

"""## K Means Clustering"""

# FOR PCA

kmeans = KMeans(n_clusters = 2)
kmeans.fit_predict(pca_X)
L = kmeans.labels_
s_score_pca = silhouette_score(pca_X,L)

print("Accuracy score for K-Means model =",accuracy_score(L, list(df['COVID-Class'])), "\n")
print("Silhouette score =",silhouette_score(pca_X,L))

plt.scatter(list(pca_X.iloc[:,0]),list(pca_X.iloc[:,1]), c=L)
plt.xlabel("C1")
plt.ylabel("C2")
plt.title("Kmeans on PCA dataset ")
plt.show()

# FOR ICA

kmeans = KMeans(n_clusters = 2)
kmeans.fit_predict(ica_X)
L = kmeans.labels_
s_score_ica = silhouette_score(ica_X,L)

print("Accuracy score for K-Means model =",accuracy_score(L, list(df['COVID-Class'])), "\n")
print("Silhouette score =",silhouette_score(ica_X,L))



plt.scatter(list(ica_X.iloc[:,0]),list(ica_X.iloc[:,1]), c=L)
plt.xlabel("C1")
plt.ylabel("C2")
plt.title("Kmeans on ICA dataset")
plt.show()

learning_models.append('KMeans')
pca_accuracies.append(s_score_pca)
ica_accuracies.append(s_score_ica)

"""# SUPERVISED LEARNING

## Gaussian Naive Bayes
"""

# FOR PCA

gnb = GaussianNB()

gnb.fit(pca_X_train,pca_Y_train)

y_pred_gnb = gnb.predict(pca_X_test)

report = classification_report(pca_Y_test,y_pred_gnb,labels=[0,1],target_names=["Non-Covid","Covid"],output_dict=True)

sb.heatmap(pd.DataFrame(report).iloc[:-1, :].T, annot=True)

learning_models.append('GNB')
pca_accuracies.append(accuracy_score(pca_Y_test,y_pred_gnb))

# FOR ICA

gnb = GaussianNB()

gnb.fit(ica_X_train,ica_Y_train)

y_pred_gnb = gnb.predict(ica_X_test)

report = classification_report(ica_Y_test,y_pred_gnb,labels=[0,1],target_names=["Non-Covid","Covid"],output_dict=True)
ica_accuracies.append(accuracy_score(ica_Y_test,y_pred_gnb))

sb.heatmap(pd.DataFrame(report).iloc[:-1, :].T, annot=True)

"""## Decision Tree Classifier (DTC)"""

# PCA

dtc = DTC()
dtc.fit(pca_X_train,pca_Y_train)
y_pred = dtc.predict(pca_X_test)
print("Accuracy score =",accuracy_score(y_pred,pca_Y_test),"\n")

dtc = DTC()
dtc.fit(pca_X_train.iloc[:,:2],pca_Y_train)
DecisionBoundaryDisplay.from_estimator(dtc,pca_X_train.iloc[:,:2],response_method="predict",xlabel='f1',ylabel='f2',alpha = 0.5)

learning_models.append('DTC')
pca_accuracies.append(accuracy_score(y_pred,pca_Y_test))

# VARYING HYPERPARAMETERS

# Max_depth
acc = []
depths = []
for d in range(2,10):
    dtc = DTC(max_depth = d)
    dtc.fit(pca_X_train,pca_Y_train)
    y_pred = dtc.predict(pca_X_test)
    depths.append(d)
    acc.append(accuracy_score(y_pred,pca_Y_test))
plt.plot(depths,acc,c="r")
plt.xlabel("Max_depths")
plt.ylabel("Accuracies")
plt.show()

# min_samples_leaf
acc = []
leaves = []
for l in range(1,10):
    dtc = DTC(min_samples_leaf = l)
    dtc.fit(pca_X_train,pca_Y_train)
    y_pred = dtc.predict(pca_X_test)
    leaves.append(l)
    acc.append(accuracy_score(y_pred,pca_Y_test))
plt.plot(leaves,acc,c="r")
plt.xlabel("Min_samples_leaf")
plt.ylabel("Accuracies")
plt.show()

# ICA

dtc = DTC()
dtc.fit(ica_X_train,ica_Y_train)
y_pred = dtc.predict(ica_X_test)
print("Accuracy score =",accuracy_score(y_pred,ica_Y_test),"\n")

dtc = DTC()
dtc.fit(ica_X_train.iloc[:,:2],ica_Y_train)
DecisionBoundaryDisplay.from_estimator(dtc,ica_X_train.iloc[:,:2],response_method="predict",xlabel='f1',ylabel='f2',alpha = 0.5)

ica_accuracies.append(accuracy_score(y_pred,ica_Y_test))

# VARYING HYPERPARAMETERS

# Max_depth
acc = []
depths = []
for d in range(2,10):
    dtc = DTC(max_depth = d)
    dtc.fit(ica_X_train,ica_Y_train)
    y_pred = dtc.predict(ica_X_test)
    depths.append(d)
    acc.append(accuracy_score(y_pred,ica_Y_test))
plt.plot(depths,acc,c="r")
plt.xlabel("Max_depths")
plt.ylabel("Accuracies")
plt.show()

# min_samples_leaf
acc = []
leaves = []
for l in range(1,10):
    dtc = DTC(min_samples_leaf = l)
    dtc.fit(ica_X_train,ica_Y_train)
    y_pred = dtc.predict(ica_X_test)
    leaves.append(l)
    acc.append(accuracy_score(y_pred,ica_Y_test))
plt.plot(leaves,acc,c="r")
plt.xlabel("Min_samples_leaf")
plt.ylabel("Accuracies")
plt.show()

"""## Random Forest Classifier (RFC)"""

# PCA

rfc = RFC()
rfc.fit(pca_X_train,pca_Y_train)
y_pred = rfc.predict(pca_X_test)
print("Accuracy score =",accuracy_score(y_pred,pca_Y_test),"\n")

rfc1 = RFC()
rfc1.fit(pca_X_train.iloc[:,:2],pca_Y_train)
DecisionBoundaryDisplay.from_estimator(rfc1,pca_X_train.iloc[:,:2],response_method="predict",xlabel='f1',ylabel='f2',alpha = 0.5)

learning_models.append('RFC')
pca_accuracies.append(accuracy_score(y_pred,pca_Y_test))

# ICA

rfc = RFC()
rfc.fit(ica_X_train,ica_Y_train)
y_pred = rfc.predict(ica_X_test)
print("Accuracy score =",accuracy_score(y_pred,ica_Y_test),"\n")

rfc2 = RFC()
rfc2.fit(ica_X_train.iloc[:,:2],ica_Y_train)
DecisionBoundaryDisplay.from_estimator(rfc2,ica_X_train.iloc[:,:2],response_method="predict",xlabel='f1',ylabel='f2',alpha = 0.5)

ica_accuracies.append(accuracy_score(y_pred,ica_Y_test))

"""## XGBoost"""

# PCA

xgb = XGBClassifier()
xgb.fit(pca_X_train,pca_Y_train)
y_pred_xgb = xgb.predict(pca_X_test)
print("Accuracy score =",accuracy_score(y_pred_xgb,pca_Y_test))
print("Area Under Curve :" + str(roc_auc_score(y_pred_xgb,pca_Y_test)),"\n")

print(classification_report(y_pred_xgb,pca_Y_test))

learning_models.append('XGB')
pca_accuracies.append(accuracy_score(y_pred_xgb,pca_Y_test))

# LDA

xgb = XGBClassifier()
xgb.fit(ica_X_train,ica_Y_train)
y_pred_xgb = xgb.predict(ica_X_test)
print("Accuracy score =",accuracy_score(y_pred_xgb,ica_Y_test))
print("Area Under Curve :" + str(roc_auc_score(y_pred_xgb,ica_Y_test)),"\n")

print(classification_report(y_pred_xgb,ica_Y_test))

ica_accuracies.append(accuracy_score(y_pred_xgb,ica_Y_test))

"""## Support Vector Machine (SVM)"""

# PCA

svm = make_pipeline(StandardScaler(), SVC(gamma='auto'))
svm.fit(pca_X_train, pca_Y_train)
y_pred_svm = svm.predict(pca_X_test)
report = classification_report(pca_Y_test,y_pred_svm,labels=[0,1],target_names=["Non-Covid","Covid"],output_dict=True)
sb.heatmap(pd.DataFrame(report).iloc[:-1, :].T, annot=True)

# Varying the kernel

accuracies = []

# 1. Linear

svm = make_pipeline(StandardScaler(), SVC(kernel="linear"))
svm.fit(pca_X_train, pca_Y_train)
y_pred_linear = svm.predict(pca_X_test)
acc1 = accuracy_score(y_pred_linear,pca_Y_test)
accuracies.append(acc1)

# 2. Sigmoid

svm = make_pipeline(StandardScaler(), SVC(kernel="sigmoid"))
svm.fit(pca_X_train, pca_Y_train)
y_pred_sigmoid = svm.predict(pca_X_test)
acc2 = accuracy_score(y_pred_sigmoid,pca_Y_test)
accuracies.append(acc2)

# 3. Polynomial

svm = make_pipeline(StandardScaler(), SVC(kernel="poly"))
svm.fit(pca_X_train, pca_Y_train)
y_pred_poly = svm.predict(pca_X_test)
acc3 = accuracy_score(y_pred_poly,pca_Y_test)
accuracies.append(acc3)

models = ["Linear","Sigmoid","Polynomial"]
plt.bar(models,accuracies,width=0.4,color=["Purple","Green","Orange"])
plt.xlabel("Kernels")
plt.ylabel("Accuracies")
plt.title("For PCA SVM")
plt.show()

learning_models.extend(['LinearSVM','SigmoidSVM','PolySVM'])
pca_accuracies.extend(accuracies)

# ICA


svm = make_pipeline(StandardScaler(), SVC(gamma='auto'))
svm.fit(ica_X_train,ica_Y_train)
y_pred_svm = svm.predict(ica_X_test)
report = classification_report(ica_Y_test,y_pred_svm,labels=[0,1],target_names=["Non-Covid","Covid"],output_dict=True)
sb.heatmap(pd.DataFrame(report).iloc[:-1, :].T, annot=True)

# Varying the kernel

accuracies = []

# 1. Linear

svm = make_pipeline(StandardScaler(), SVC(kernel="linear"))
svm.fit(ica_X_train, ica_Y_train)
y_pred_linear = svm.predict(ica_X_test)
acc1 = accuracy_score(y_pred_linear,ica_Y_test)
accuracies.append(acc1)

# 2. Sigmoid

svm = make_pipeline(StandardScaler(), SVC(kernel="sigmoid"))
svm.fit(ica_X_train, ica_Y_train)
y_pred_sigmoid = svm.predict(ica_X_test)
acc2 = accuracy_score(y_pred_sigmoid,ica_Y_test)
accuracies.append(acc2)

# 3. Polynomial

svm = make_pipeline(StandardScaler(), SVC(kernel="poly"))
svm.fit(ica_X_train, ica_Y_train)
y_pred_poly = svm.predict(ica_X_test)
acc3 = accuracy_score(y_pred_poly,ica_Y_test)
accuracies.append(acc3)

ica_accuracies.extend(accuracies)

models = ["Linear","Sigmoid","Polynomial"]
plt.bar(models,accuracies,width=0.4,color=["Purple","Green","Orange"])
plt.xlabel("Kernels")
plt.ylabel("Accuracies")
plt.title("ForICA SVM")
plt.show()

"""# COMPARATIVE STUDY OF MODELS"""

# Accuracy for KMeans = 0.844 (PCA) and 0.905 (LDA)
# What we have earlier considered was the silhouette score.

pca_accuracies[0] = 0.844
ica_accuracies[0] = 0.905

plt.figure(figsize=(10, 4))
plt.bar(learning_models,pca_accuracies)
plt.title("PCA")
plt.ylabel('pca_accuracies')
plt.xlabel('learning_models')
values=[round(acc, 2) for acc in pca_accuracies]

for i, v in enumerate(values):
    plt.text(i, v +0.011, (str(v*100)+'%'))

plt.show()

plt.figure(figsize=(10, 4))
plt.bar(learning_models,ica_accuracies)
plt.title("ICA")
plt.ylabel('ica_accuracies')
plt.xlabel('learning_models')

values=[round(acc, 2) for acc in ica_accuracies]

for i, v in enumerate(values):
    plt.text(i, v +0.011, (str(v*100)+'%'))

plt.show()

plt.figure(figsize=(10, 4))
plt.plot(learning_models,pca_accuracies,marker='x',color='orange')
plt.plot(learning_models,ica_accuracies,marker='p',color='blue')
plt.xlabel('model')
plt.ylabel('accuracy')
plt.title('Comparing Accuracies')
plt.legend(['PCA','ICA'],loc='best')